---
title: "Clustering"
output:
  html_document: 
    code_folding: hide
    toc: true
    toc_float: true
    css: mystyle.css
---

```{r, echo = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE
)
```

## Brief Explanation 

One of the main goals referred to in the economic development literature is the need to fight and eradicate poverty. However, in order for economic policies to be efficient, it is highly important to properly understand and establish the target of such policies (the poorest). In this paper, we propose a new methodology based on a multivariate approach to determine the profile of the poorest in Tanzania. Through the application of Monge-Kantarovich’s depth measure and Voronoi’s iteration, we see that variables such as the quality of health or the access to supplies play crucial roles in the correct
measurement of poverty in Tanzania.

```{r setup}
library(tidyverse)
library(refund.shiny)
```

## Practical example

Due to a lack of publicly available and easy-to-implement code for scalar-on-image regression, we focus on methods for the functional linear concurrent model. 

The snippet below simulates a simple example which we will use for illustration. 

```{r vbvs_sim_data}
## set design elements
set.seed(1)
I = 50

## coefficient functions
beta1 = function(t) { 1 }
beta2 = function(t) { cos(2*t*pi) }
psi1 = function(t) { sin(2*t*pi) }

## generate subjects and observation times
concurrent_data = 
  data.frame(
    subj = rep(1:I, each = 20)
  ) %>%
  mutate(time = runif(dim(.)[1])) %>%
  arrange(subj, time) %>%
  group_by(subj) %>%
    mutate(Cov_1 = runif(1, .5, 1.5) * sin(2 * pi * time),
           Cov_2 = runif(1, 0, 1) + runif(1, -.5, 2) * time,
    			 FPC_score = rnorm(1, 0, .5),
           Y = Cov_1 * beta1(time) + 
               Cov_2 * beta2(time) +
    			 	   FPC_score * psi1(time) + 
               rnorm(20, 0, .5)) %>%
  ungroup() %>%
	dplyr::select(subj, time, Y, everything())

superfulous_covariates = matrix(rnorm(18 * I * 20),	nrow = I * 20, ncol = 18)
colnames(superfulous_covariates) = paste0("Cov_", 3:20)

concurrent_data = bind_cols(concurrent_data, as.data.frame(superfulous_covariates))
```

The plot below shows the first two predictors and the response, highlighting four subjects.

```{r plot_data, fig.align='center', fig.height=3, fig.width=9, echo=FALSE}
library(gridExtra)

plot_function = function(value_var, data) {
  ggplot(data, aes_string(x = "time", y = value_var, group = "subj")) + geom_path(alpha = .1) +
    theme_bw() +
    geom_path(data = filter(data, subj %in% 1:4) %>% mutate(subj = as.factor(subj)), aes(color = subj)) + 
    theme(legend.position = "none")
}

panels = lapply(c("Cov_1", "Cov_2", "Y"), plot_function, data = concurrent_data)

grid.arrange(panels[[1]], panels[[2]], panels[[3]], nrow = 1)

```

## Try it yourself!

As in all other examples, the preceding approach has tuning parameters. These can be set by hand using the _v0_ argument to the `vbvs_concurrent` function. There is also a `cv_vbvs_concurrent` function, and versions without variable selection.

As an alternative to the functional linear concurrent model, note that the functional linear model is a special case; by carefully constructing the data frame containing predictions, `vbvs_concurrent` can be used for variable selection in that setting, and is interesting to compare to other methods we've seen so far.
